# 多层索引（MultiIndex）操作说明文档

## 概述
本程序演示了Pandas中多层索引（MultiIndex）的创建和各种操作，包括选取子集、交换分层、排序等功能。

## 数据结构

### 原始数据
基于学生成绩表，包含：
- **行索引**：班级（1班、2班）+ 姓名（张三、李四、王五、鲁班、张三丰、张无忌）
- **列索引**：时间（期中、期末）+ 科目（语文、数学、英语）

```
时间      期中          期末        
科目      语文  数学  英语  语文  数学  英语
班级 姓名                         
1班 张三   40  51  30  16  57  45
   李四   74  45  70  48  75   1
   王五   57  45  35  25  22  76
2班 鲁班   93  80  69  31  17  29
   张三丰  90  38  36  77  56  30
   张无忌  35  50  79  45  38  76
```

## 主要功能演示

### 1. 选取子集操作

#### 1.1 按班级选取
```python
df.loc['1班']  #选取1班所有数据
```

#### 1.2 按学生选取
```python
df.loc[('1班', '张三')]  #选取特定学生
```

#### 1.3 按时间选取
```python
df['期中']  #选取期中成绩
```

#### 1.4 按科目选取
```python
df[('期末', '数学')]  #选取期末数学成绩
```

#### 1.5 使用xs方法
```python
df.xs('2班', level='班级')  #跨层级选取
```

#### 1.6 多条件选取
```python
df.loc[[('1班', '张三'), ('1班', '李四')]]  #选取多个学生
```

#### 1.7 切片选取
```python
df.loc[:, ('期中', ['语文', '数学'])]  #选取期中的语文和数学
```

### 2. 交换分层操作

#### 2.1 交换行索引层级
```python
df.swaplevel('班级', '姓名')  #将姓名放在第一层
```
结果：
```
姓名  班级                        
张三  1班  40  51  30  16  57  45
李四  1班  74  45  70  48  75   1
...
```

#### 2.2 交换列索引层级
```python
df.swaplevel('时间', '科目', axis=1)  #将科目放在第一层
```
结果：
```
科目      语文  数学  英语  语文  数学  英语
时间      期中  期中  期中  期末  期末  期末
```

#### 2.3 同时交换行列索引
```python
df.swaplevel(0, 1).swaplevel(0, 1, axis=1)
```

### 3. 排序操作

#### 3.1 按索引排序（升序）
```python
df.sort_index()  #按班级和姓名排序
```

#### 3.2 按索引降序排序
```python
df.sort_index(ascending=False)  #降序
```

#### 3.3 按特定层级排序
```python
df.sort_index(level='姓名')  #只按姓名排序
```

#### 3.4 按值排序
```python
df.sort_values(by=('期中', '语文'), ascending=False)  #按期中语文成绩排序
```

#### 3.5 交换层级后排序
```python
df.swaplevel('班级', '姓名').sort_index()  #先交换再排序
```

### 4. 综合应用

#### 4.1 计算总分
```python
df['总分'] = df.sum(axis=1)
```

#### 4.2 计算平均分
```python
df.mean(axis=0)  #每科平均分
```

#### 4.3 按班级分组统计
```python
df.groupby(level='班级').mean()
```

#### 4.4 找最高分
```python
df[('期中', '语文')].idxmax()  #返回('2班', '鲁班')
```

#### 4.5 条件筛选
```python
final_sum = df['期末'].sum(axis=1)
df[final_sum > 150]  #筛选期末总分>150的学生
```

### 5. 重置和设置索引

#### 5.1 重置索引
```python
df.reset_index()  #将多层索引转为普通列
```

#### 5.2 设置索引
```python
df.set_index(['班级', '姓名'])  #将列设为多层索引
```

#### 5.3 stack操作
```python
df.stack(level='时间')  #将列索引转为行索引
```

#### 5.4 unstack操作
```python
df.unstack(level='班级')  #将行索引转为列索引
```

### 6. 高级操作

#### 6.1 条件筛选
```python
df_simple[(df_simple['班级'] == '1班') & (df_simple['总分'] > 200)]
```

#### 6.2 透视表
```python
pd.pivot_table(df, values=['期中', '期末'], index='班级', aggfunc='mean')
```

#### 6.3 IndexSlice切片
```python
idx_slice = pd.IndexSlice
df.loc[idx_slice[:, ['张三', '李四']], idx_slice['期中', :]]
```

### 7. 统计分析

#### 7.1 描述性统计
```python
df.describe()  #count, mean, std, min, max等
```

#### 7.2 相关性分析
```python
df[['期中', '期末']].corrwith(df[['期末', '期中']])
```

#### 7.3 排名
```python
df['排名'] = df['总分'].rank(ascending=False, method='min')
```

## 关键要点

### 多层索引的优势
1. **层次化数据组织**：适合表示具有多个维度的数据
2. **灵活的数据选取**：可以按不同层级选取数据
3. **高效的分组操作**：便于按不同维度进行统计分析
4. **数据重塑**：通过stack/unstack轻松转换数据形状

### 常用方法总结

| 操作类型 | 方法 | 说明 |
|---------|------|------|
| 创建 | `pd.MultiIndex.from_arrays()` | 从数组创建 |
| 创建 | `pd.MultiIndex.from_product()` | 从笛卡尔积创建 |
| 选取 | `loc[]` | 标签选取 |
| 选取 | `xs()` | 跨层级选取 |
| 交换 | `swaplevel()` | 交换层级顺序 |
| 排序 | `sort_index()` | 按索引排序 |
| 排序 | `sort_values()` | 按值排序 |
| 重塑 | `stack()` | 列转行 |
| 重塑 | `unstack()` | 行转列 |
| 重置 | `reset_index()` | 索引转列 |
| 设置 | `set_index()` | 列转索引 |

### 注意事项

1. **索引排序**：多层索引最好保持排序状态，提高查询性能
2. **元组访问**：访问多层索引时使用元组，如`df.loc[('1班', '张三')]`
3. **切片语法**：使用`IndexSlice`可以更方便地进行切片操作
4. **内存效率**：多层索引比重复列更节省内存
5. **层级名称**：建议为每个层级命名，便于理解和操作

## 运行结果

程序运行后会输出：
1. 原始多层索引数据
2. 各种选取子集的示例
3. 交换分层的效果
4. 多种排序方式的结果
5. 综合应用案例
6. 重置和设置索引的演示
7. 高级操作示例
8. 统计分析结果

详细输出请查看：`多层索引输出.txt`

## 实际应用场景

1. **时间序列数据**：日期 + 股票代码
2. **地理数据**：国家 + 省份 + 城市
3. **实验数据**：实验组 + 时间点 + 指标
4. **销售数据**：地区 + 产品 + 时间
5. **学生成绩**：班级 + 学生 + 科目（本例）

## 文件说明

- `多层索引操作.py` - 完整的演示代码
- `多层索引输出.txt` - 程序运行的完整输出
- `多层索引操作说明.md` - 本说明文档

---

**创建时间**：2025年12月4日  
**Python版本**：3.x  
**依赖库**：pandas, numpy
